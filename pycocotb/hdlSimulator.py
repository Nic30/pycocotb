"""
[TODO] sphinx friendly format

Pitfalls of delta-step based HDL simulators

* If we update circuit signal by signal there is no problem.
  But we want to perform multiple IO changes in circuit to achieve better performance.
  If we perform multiple signal changes the IO ends up in final state only.
  That means that simulation agents may possibly miss some event which they were waiting for.
  Sequential evaluation can still be forced by using explicit events
  but there is only a few IO protocols where this is required.

##############################################################
m.vld          s.rd
>----------------->
m.data       s.data
>----------+1----->

Expected functionality if vld: s.data=m.data+1
Problem:
1. m.vld = 0; m.data = 0
2. m.vld = 1; m.data = 1
   * result: s.data captured 2 # because s.data was captured late
   * expected: s.data captured 1
   * reason: wrong definition communication protocol
   * solution: wait on WriteOnly after writing m.vld
       to resolve combinational loops.
       Or use clock signal to synchronize simulation agents.

##############################################################

clk_in      clk_out
>----------------->
m.data   |   s.data
>------[ff]--+1--->
m.vld          s.rd
>----------------->

Expected functionality if s.rd and RISING_EDGE(clk_out): s.data=prev(m.data)+1
Problem:
1. m.vld = 0; m.data = 0; clk_in = 0
2. m.vld = 1; m.data = 1; clk_in = 1
    * result: s.data = 2 # because ff was loaded when clk_in risen
    * expected: s.data = 1
    * reason: there is a combinational path but simulation agent is synchronized
        at the end of step by clk signal generated by circuit
    * solution: wait on WriteOnlyClk before write to clk_in


# Simulator delta step:

* PRESET - write only, stacked values applied first, read raising error
* eval() call
    * combinational update                   -|
    * COMB_UPDATED - read only                | Care for comb. loops
    * COMB_REWRITE - write only               | in sim agents
    * raise ResetEval() if write was used     |
    * COMB_STABLE - read only                -|
    * BEFORE_EDGE(clk0)
        - read only                                     -|
          (clock sig. updated but none of the registers) | Care for
    * clk0 event resolution                              | clock dependent
        - (update of all registers                       | agents
           for clock and comb. path behind them)        -|
* END_OF_STEP - read only                    -| Final state resolution


# Run of the simulator:

* eval_init()
* END_OF_STEP - read only
* while True:
    * delata_step()
"""

from heapq import heappush, heappop
from typing import Tuple

from pycocotb.triggers import Event, raise_StopSimulation, Timer, \
    StopSimumulation, PRIORITY_URGENT, PRIORITY_NORMAL, ReadOnly, \
    WriteOnly, WriteClkOnly
from inspect import isgenerator


# [TODO] use red-black tree
# internal
class CalendarItem():

    def __init__(self, time: int, sub_step: int, priority: int, value):
        """
        :param time: time when this event this list of event should be evoked
        :param sub_step: index of delta step in this time
            (there is read/write phase cycle to settle values down)
        :param priority: priority as described in this file
        """
        self.key = (time, sub_step, priority)
        self.value = value

    def __lt__(self, other):
        return self.key < other.key


# internal
class SimCalendar():
    """
    Priority queue where key is time and priority
    """

    def __init__(self):
        self._q = []

    def push(self, time: int, step_no: int, priority: int, value):
        item = CalendarItem(time, step_no, priority, value)
        heappush(self._q, item)

    def pop(self) -> Tuple[int, int, int, object]:
        item = heappop(self._q)
        return (*item.key, item.value)


# similar to https://github.com/potentialventures/cocotb/blob/master/cocotb/scheduler.py
class HdlSimulator():
    """
    This simulator simulates the communcation between circut simulator
    and simulation procesesses which are driving the simulation.
    Simulation processes are usually provided by simulation agents or user.

    .. note: *Delta steps*
        Delta step is minimum quantum of changes in simulation.

    :ivar now: actual simulation time
    :ivar _events: heap of simulation events and processes
    :ivar rtl_simulator: circuit simulator used for simulation of circuit itself
    """

    def __init__(self, rtl_simulator):
        super(HdlSimulator, self).__init__()
        self.rtl_simulator = rtl_simulator
        self.now = 0

        # container of outputs for every process
        self._events = SimCalendar()

    # internal
    def _add_process(self, proc, priority) -> None:
        """
        Schedule process on actual time with specified priority
        """
        self._events.push(self.now, priority, proc)

    def _run_process(self, process, now, step_no, priority, schedule):
        # run process or activate processes dependent on Event
        while True:
            try:
                # print(now, process)
                ev = next(process)
            except StopIteration:
                break

            # if process requires waiting put it back in queue
            if isinstance(ev, Timer):
                # put process to sleep as required by Timer event
                schedule(now + ev.time, 0, priority, process)
                break
            elif isinstance(ev, Event):
                # process going to wait for event
                # if ev.process_to_wake is None event was already
                # destroyed
                ev.process_to_wake.append(process)
                break
            elif isgenerator(ev):
                # else this process spotted new process
                # and it has to be put in queue
                schedule(now, priority, ev)
            else:
                # process is going to wait on different simulation step
                if priority <= ev.PRIORITY:
                    step_no += 1
                schedule(now, step_no, ev.PRIORITY, process)
                break

    def run(self, until: float, extraProcesses=[]) -> None:
        """
        Run simulation for a specified time

        :note: Can be used to run simulation again after it ends from time when it ends.
        :note: Dimulator restart is performed by new instantiation of the simulator.
        """
        add_proc = self.add_process
        for p in extraProcesses:
            add_proc(p(self))

        assert until >= self.now, (until, self.now)
        if until == self.now:
            return

        events = self._events

        # schedule = events.push
        def schedule(*args):
            # print(*args)
            events.push(*args)

        next_event = events.pop

        # add handle to stop simulation
        now, step_no, priority = (self.now, 0, ReadOnly.PRIORITY)
        schedule(now + until, 0, PRIORITY_URGENT, raise_StopSimulation(self))

        rtl_sim = self.rtl_simulator
        rtl_pending_event_list = rtl_sim.pending_event_list
        try:
            # for all events
            while True:
                now, step_no, priority, process = next_event()
                eval_circuit = now > self.now or priority == WriteOnly.PRIORITY or priority == WriteClkOnly.PRIORITY  # [TODO]
                if eval_circuit:
                    while True:
                        # use while because we are resolving combinational loops
                        # between event callbacks and rtl_simulator
                        # print("eval", self.now)
                        rtl_sim.eval()
                        for _process in rtl_pending_event_list:
                            if not isgenerator(_process):
                                _process = _process(self)

                            self._run_process(_process, self.now, 0, PRIORITY_NORMAL, schedule)

                        if not rtl_pending_event_list:
                            break  # no callback triggered another callback

                        rtl_pending_event_list.clear()

                rtl_sim.time = self.now = now

                # process is Python generator or Event
                if isinstance(process, Event):
                    process = iter(process)

                self._run_process(process, now, step_no, priority, schedule)

        except StopSimumulation:
            return

    def add_process(self, proc) -> None:
        """
        Add process to events with default priority on current time
        """
        self._events.push(self.now, 0, PRIORITY_NORMAL, proc)

