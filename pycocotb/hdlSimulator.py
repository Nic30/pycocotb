"""
Pitfalls of delta-step based HDL simulators

* Situation
    * RTL simulator which simulates behavior of circuit step by step
    * Simulation environment (=simulator) composed of user specified processes.
        * Simulator can read all signals in RTL simulator
        * Simulator can write and wait for event only on top level signals.

* Problem is how to ensure correct order of operations in RTL simulator
  and in user specified processes which are controlling RTL simulator
  while keeping simulation simple.

    * Requirements of UVM like interface agents.

        * Agents need to be able:

            * Perform combinational loop (e.g. tristate pull-up in I2C)

            * Wait for (before and after) edge of clock signal (e.g. BRAM port)

                * Clock signal can be driven directly by sim.
                  If this is a case synchronization is simple because simulator
                  and user knows when the event happens (before call delta step).

                * If clock signal is generated by circuit it is problematic because
                  value of clock signal is updated in simulation step together
                  with another signal updates. This can result in incorrect
                  event order and special care is required.

                * After clock event is used to signalize that clock cycle
                  has passed and state of interface and it's agent can be updated.
                  This event is triggered on the end of delta step
                  as it can be triggered only once per delta step.

            * Perform combinational loop for clock signals.

                * Value has to be updated in same step.

                    * Problem is that in simulator code some other events
                      may be pending, extra care is required.

        * Agent is full description of interface protocol and should be universal
          and extensible.

    * Combinational loops between simulator and RTL simulator.

        * If only one signal is updated per delta step there is no problem.

        * However if multiple signals signals (especially clock signals)
          are updated in same delta step combinational loop does not
          have to be resolved before some event dependent (e.g. FF) update
          This results in invalid resolution.

            * Updates of combinational logic has to be resolved before update
              of sequential logic.

    * Clock generated by RTL simulator.

        * Output signals from RTL simulator does not have to have
          values which they have when clock event was triggered, solution:

            * Manually add registers in to circuit to hold correct value.

            * Run simulation process which waits on event on specified signal
              exactly in time of the event. Problem is that in this state some
              values can be undefined and read only access is required.

# Simulator delta step:

* (Event names written in capital)

def delta_step():
    * PRESET - write only
    * RTL simulator eval() call
        * combinational update                     -|
        * COMB_UPDATE - read only                   | Care for comb. loops
        * COMB_REWRITE - write only                 | in sim. agents
        * rerun eval() if write was used            |
        * COMB_STABLE - read only                  -|
        * check for event on signals driven by sim -| Care for sim. driven events
        * for each clock signal:
            * BEFORE_EDGE(clk) - read only                  -| Care for clock
            * for each start of evaluation                   | dependent agents
              of event dependent code                        | where clock is generated
              (clock sig. updated but none of the registers)-| from circuit
    * END_OF_STEP - read only                    -| Final state resolution

# Run of the simulator:

* eval_init()
* END_OF_STEP - read only
* while True:
    * delta_step()
"""

from heapq import heappush, heappop
from typing import Tuple

from pycocotb.triggers import Event, raise_StopSimulation, Timer, \
    StopSimumulation, PRIORITY_URGENT, ReadOnly, \
    WriteOnly, CombStable, AllStable
from inspect import isgenerator
from enum import Enum


# [TODO] use c++ red-black tree
# internal
class CalendarItem():

    def __init__(self, time: int, priority: int, value):
        """
        :param time: time when this event this list of event should be evoked
        :param priority: priority as described in this file
        """
        self.key = (time, priority)
        self.value = value

    def __lt__(self, other):
        return self.key < other.key

    def __repr__(self):
        return "<CalendarItem %r %r>" % (self.key, self.value)


class RecheckTopEvent(Exception):
    pass


# internal
class SimCalendar():
    """
    Priority queue where key is time and priority
    """

    def __init__(self):
        self._q = []

    def push(self, time: int, priority: int, value):
        item = CalendarItem(time, priority, value)
        heappush(self._q, item)

    def top(self):
        item = self._q[0]
        return (*item.key, item.value)

    def pop(self) -> Tuple[int, int, int, object]:
        item = heappop(self._q)
        return (*item.key, item.value)

    def __repr__(self):
        q = "\n    ".join([repr(i) for i in self._q])
        return "<SimCalendar size:%d %s>" % (len(self._q), q)


# similar to https://github.com/potentialventures/cocotb/blob/master/cocotb/scheduler.py
class HdlSimulator():
    """
    This simulator simulates the communication between circuit simulator
    and simulation processes which are driving the circuit simulation.
    Simulation processes are usually provided by simulation agents or user.

    :ivar now: actual simulation time
    :ivar _events: heap of simulation events and processes
    :ivar rtl_simulator: circuit simulator used for simulation of circuit itself
    """

    def __init__(self, rtl_simulator):
        super(HdlSimulator, self).__init__()
        self.rtl_simulator = rtl_simulator
        self.now = 0
        # container of outputs for every process
        self._events = SimCalendar()

    # internal
    def _add_process(self, proc, priority) -> None:
        """
        Schedule process on actual time with specified priority
        """
        self._events.push(self.now, priority, proc)

    def _run_process(self, process, priority, schedule):
        # run process or activate processes dependent on Event
        for ev in process:
            # if process requires waiting put it back in queue
            if isinstance(ev, Timer):
                # put process to sleep as required by Timer event
                schedule(self.now + ev.time, ev.priority, process)
                break
            elif isinstance(ev, Event):
                # process going to wait for event
                # if ev.process_to_wake is None event was already
                # destroyed
                ev.process_to_wake.append(process)
                break
            elif isgenerator(ev):
                # else this process spotted new process
                # and it has to be put in queue
                schedule(self.now, priority, ev)
            else:
                # process is going to wait on different simulation step
                p = ev.PRIORITY
                if p == priority:
                    continue

                schedule(self.now, ev.PRIORITY, process)
                break

    def run(self, until: int, extraProcesses=[]) -> None:
        """
        Run simulation for a specified time

        :note: Can be used to run simulation again after it ends from time when it ends.
        :note: Simulator restart is performed by new instantiation of the simulator.
        """
        add_proc = self.add_process
        for p in extraProcesses:
            add_proc(p(self))

        assert until >= self.now, (until, self.now)
        if until == self.now:
            return

        # schedule = self._events.push
        def schedule(*args):
            assert self.now <= args[0]
            print(self.now, "sched:", *args)
            self._events.push(*args)

        next_event = self._events.pop
        top_event = self._events.top

        WrP = WriteOnly.PRIORITY
        now, priority = (self.now, WrP)
        # add handle to stop simulation
        schedule(now + until, PRIORITY_URGENT, raise_StopSimulation(self))

        rtl_sim = self.rtl_simulator
        rtl_pending_event_list = rtl_sim._pending_event_list

        COMB_UPDATE_DONE = rtl_sim._COMB_UPDATE_DONE
        COMB_UPDATE = COMB_UPDATE_DONE - 1
        BEFORE_EDGE = rtl_sim._BEFORE_EDGE
        END_OF_STEP = rtl_sim._END_OF_STEP
        PRIORITY_TO_STATE = {
            WriteOnly.PRIORITY: COMB_UPDATE,
            ReadOnly.PRIORITY: COMB_UPDATE_DONE,
            CombStable.PRIORITY: COMB_UPDATE_DONE,
            AllStable.PRIORITY: END_OF_STEP,
            PRIORITY_URGENT: END_OF_STEP,  # [TODO] now used only for end of sim.
        }
        STATE_TO_PRIORITY = {
            COMB_UPDATE: WriteOnly.PRIORITY,
            COMB_UPDATE_DONE: ReadOnly.PRIORITY,
            END_OF_STEP: AllStable.PRIORITY,
        }

        # state of RTL simulator is beeing updated and updates are pending
        rtlState = COMB_UPDATE
        rtlStateDirty = True
        lastRtlUpdateFinishTime = self.now - 1
        try:
            # for all events
            while True:
                try:
                    print(self.now)
                    next_time, next_priority, _ = top_event()
                    # if there was an update of IO of circuit perform update
                    required_state = PRIORITY_TO_STATE[next_priority]

                    while rtlState != required_state or (
                            rtlStateDirty and next_time > now):
                        # use while because we are resolving combinational loops
                        # between event callback and rtl_simulator
                        eval_end_t = rtl_sim._eval()
                        print("eval", eval_end_t)
                        do_recheckTopEv = False
                        if rtl_pending_event_list:
                            # proper solution is to put triggered events to sim.
                            # calendar with urgent priority  but we evaluate
                            # it directly because of performance
                            for _process in rtl_pending_event_list:
                                if not isgenerator(_process):
                                    _process = _process(self)

                                self._run_process(_process, STATE_TO_PRIORITY[rtlState], schedule)
                            rtl_pending_event_list.clear()
                            do_recheckTopEv = True

                        if eval_end_t == COMB_UPDATE_DONE:
                            rtlState = COMB_UPDATE_DONE
                        elif eval_end_t == END_OF_STEP:
                            rtlState = END_OF_STEP
                            rtlStateDirty = False
                            assert lastRtlUpdateFinishTime < self.now, ("Simulator hang in ", self.now)
                            lastRtlUpdateFinishTime = self.now
                            if next_time > now:
                                # reset the simulation step if noone is waition on finish

                                # if top event changed
                                tmp = top_event()
                                if tmp[0] != next_time:
                                    do_recheckTopEv = True
                                else:
                                    print("step restart")
                                    rtl_sim._set_write_only()
                                    rtlState = COMB_UPDATE

                            break

                        if do_recheckTopEv:
                            print("recheck")
                            raise RecheckTopEvent()

                    if next_priority == WriteOnly.PRIORITY:
                        rtlStateDirty = True

                    now, priority, process = next_event()
                    assert now >= self.now, (now, process)
                    rtl_sim._time = self.now = now

                    # process is Python generator or Event
                    if isinstance(process, Event):
                        process = iter(process)
                    
                    self._run_process(process, priority, schedule)
                except RecheckTopEvent:
                    continue
        except StopSimumulation:
            return

    def add_process(self, proc) -> None:
        """
        Add process to events with default priority on current time
        """
        self._events.push(self.now, WriteOnly.PRIORITY, proc)

