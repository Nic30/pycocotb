from heapq import heappush, heappop
from typing import Tuple, Generator

from pycocotb.triggers import Event, raise_StopSimulation, Timer, \
    StopSimumulation, PRIORITY_URGENT, SimStep, PRIORITY_NORMAL


# internal
class CalendarItem():

    def __init__(self, time: int, sub_step: int, priority: int, value):
        """
        :param time: time when this event this list of event should be evoked
        :param sub_step: index of delta step in this time
            (there is read/write phase cycle to settle values down)
        :param priority: priority as described in this file
        """
        self.key = (time, sub_step, priority)
        self.value = value

    def __lt__(self, other):
        return self.key < other.key


# internal
class SimCalendar():
    """
    Priority queue where key is time and priority
    """

    def __init__(self):
        self._q = []

    def push(self, time: int, step_no: int, priority: int, value):
        item = CalendarItem(time, step_no, priority, value)
        heappush(self._q, item)

    def pop(self) -> Tuple[int, int, int, object]:
        item = heappop(self._q)
        return (*item.key, item.value)

# similar to https://github.com/potentialventures/cocotb/blob/master/cocotb/scheduler.py

"""
Pitfalls of delta-step based HDL simulators

* If we update circuit signal by signal there is no problem.
  But we want to perform multiple IO changes in circuit to achieve better performance.
  If we perform multiple signal changes the IO ends up in final state only.
  That means that simulation agents may possibly miss some event which they were waiting for.
  Sequential evaluation can still be forced by using explicit events
  but there is only a few IO protocols where this is required.

##############################################################
m.vld          s.rd
>----------------->
m.data       s.data
>----------+1----->

Expected functionality if vld: s.data=m.data+1
Problem:
1. m.vld = 0; m.data = 0
2. m.vld = 1; m.data = 1
   * result: s.data captured 2 # because s.data was captured late
   * expected: s.data captured 1
   * reason: wrong definition communication protocol
   * solution: wait on WriteOnly after writing m.vld
       to resolve combinational loops.
       Or use clock signal to synchronize simulation agents.

##############################################################

clk_in      clk_out
>----------------->
m.data   |   s.data
>------[ff]--+1--->
m.vld          s.rd
>----------------->

Expected functionality if s.rd and RISING_EDGE(clk_out): s.data=prev(m.data)+1
Problem:
1. m.vld = 0; m.data = 0; clk_in = 0
2. m.vld = 1; m.data = 1; clk_in = 1
    * result: s.data = 2 # because ff was loaded when clk_in risen
    * expected: s.data = 1
    * reason: there is a combinational path but simulation agent is synchronized
        at the end of step by clk signal generated by circuit
    * solution: wait on WriteOnlyClk before write to clk_in

"""


class HdlSimulator():
    """
    Circuit simulator with support for external agents

    .. note: *Delta steps*
        Delta step is minimum quantum of changes in simulation, on the beginning
        of delta step all reads are performed and on the end all writes
        are performed. Writes are causing re-evaluation of HWprocesses
        which are scheduled into next delta step.
        Delta steps does not update time.
        When there is no process to reevaluate that means there is nothing to do
        in delta step this delta step is considered as last in this time
        and time is shifted on beginning of next event by simulator.
        The first delta step is different. It begins with write substep.
        And performs the initialization before any read.

    .. note:: *Simulation inputs*
        Simulation processes are written in Python and can contain anything
        including blocking statements realized by yield Timer(time).
        (Using hdl as main simulator driver is not efficient.)

    :ivar now: actual simulation time
    :ivar _events: heap of simulation events and processes
    """

    def __init__(self, rtl_simulator):
        super(HdlSimulator, self).__init__()
        self.rtl_simulator = rtl_simulator
        self.now = 0

        # container of outputs for every process
        self._events = SimCalendar()

    # internal
    def _add_process(self, proc, priority) -> None:
        """
        Schedule process on actual time with specified priority
        """
        self._events.push(self.now, priority, proc)

    def run(self, until: float, extraProcesses=[]) -> None:
        """
        Run simulation until specified time
        :note: can be used to run simulation again after it ends from time when it ends
        """
        add_proc = self.add_process
        for p in extraProcesses:
            add_proc(p(self))

        assert until >= self.now, (until, self.now)
        if until == self.now:
            return

        events = self._events
        schedule = events.push
        next_event = events.pop

        # add handle to stop simulation
        schedule(until, PRIORITY_URGENT, 0, raise_StopSimulation(self))

        rtl_sim = self.rtl_simulator
        rtl_pending_event_list = rtl_sim.pending_event_list
        try:
            # for all events
            while True:
                now, step_no, priority, process = next_event()
                rtl_sim.time = self.now = now

                rtl_sim.eval()
                for cb in rtl_pending_event_list:
                    cb(self)
                rtl_pending_event_list.clear()

                # process is Python generator or Event
                if isinstance(process, Event):
                    process = iter(process)

                # run process or activate processes dependent on Event
                while True:
                    try:
                        ev = next(process)
                    except StopIteration:
                        break

                    # if process requires waiting put it back in queue
                    if isinstance(ev, Timer):
                        # put process to sleep as required by Timer event
                        schedule(now + ev.time, 0, priority, process)
                        break
                    elif isinstance(ev, Event):
                        # process going to wait for event
                        # if ev.process_to_wake is None event was already
                        # destroyed
                        ev.process_to_wake.append(process)
                        break
                    elif issubclass(ev, SimStep):
                        # process is going to wait on different simulation step
                        if priority <= ev.PRIORITY:
                            step_no += 1
                        schedule(now, step_no, ev.PRIORITY, process)
                        break
                    else:
                        # else this process spoted new process
                        # and it has to be put in queue
                        schedule(now, priority, ev)

        except StopSimumulation:
            return

    def add_process(self, proc) -> None:
        """
        Add process to events with default priority on current time
        """
        self._events.push(self.now, 0, PRIORITY_NORMAL, proc)

