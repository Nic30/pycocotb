#include <verilated.h>
#include <Python.h>
#include <structmember.h>
#include <vector>

#include "signal_mem_proxy.h"
#include "V{{top_name}}.h"

typedef struct {
    PyObject_HEAD
	V{{top_name}} *dut;
	std::vector<SignalMemProxy_t*> signals;
} Sim_t;

static PyObject *
Sim_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
	Sim_t *self;

    self = (Sim_t *)type->tp_alloc(type, 0);
    if (self != nullptr) {
    	self->dut = new V{{top_name}}("{{top_name}}");
        if(!self->dut) {
            PyErr_SetString(PyExc_AssertionError, "Can not create new instance of simulation");
        	return nullptr;
        }
		SignalMemProxy_t *proxy = nullptr;
		{% for signal_name, read_only, is_signed, type_info in accessible_signals %}
		proxy = PyObject_NEW(SignalMemProxy_t, &SignalMemProxy_pytype);
		SignalMemProxy_c_init(proxy, true,
				reinterpret_cast<uint8_t*>(&self->dut->{{signal_name}}),
				{{type_info}}, {{is_signed}}, "{{signal_name}}");
		self->signals.push_back(proxy);
		{% endfor %}

    }
    return (PyObject *)self;
}

static void
Sim_dealloc(Sim_t* self)
{
	self->dut->final();
	delete self->dut;
	Py_TYPE(self)->tp_free((PyObject*)self);
}


static PyObject *
Sim_eval(Sim_t* self, PyObject* args)
{
    self->dut->eval();

    Py_INCREF(Py_None);
    return Py_None;
}


static PyMethodDef Sim_methods[] = {
        {"eval", (PyCFunction)Sim_eval, METH_NOARGS, "single simulation step"},
        {nullptr}  /* Sentinel */
};

PyObject * Sim_attr_simple_getter(Sim_t * self, void * closure) {
	auto proxy = self->signals.at(reinterpret_cast<size_t>(closure));
	Py_INCREF(proxy);
	return (PyObject*)proxy;
}

static PyGetSetDef Sim_getters_setters[] = {
		{% for signal_name, read_only, is_signed, type_info in accessible_signals %}
        {(char *)"{{signal_name}}", (getter)Sim_attr_simple_getter, nullptr,
			(char *)"simulation proxy for clk signal", (void*){{ loop.index - 1 }}},
		{% endfor %}
		{nullptr}  /* Sentinel */
};

static PyTypeObject Sim_pytype = {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "{{module_name}}",            /* tp_name */
    sizeof(Sim_t),   /* tp_basicsize */
    0,                          /* tp_itemsize */
    (destructor)Sim_dealloc, /* tp_dealloc */
    0,                          /* tp_print */
    0,                          /* tp_getattr */
    0,                          /* tp_setattr */
    0,                          /* tp_reserved */
    0,                          /* tp_repr */
    0,                          /* tp_as_number */
    0,                          /* tp_as_sequence */
    0,                          /* tp_as_mapping */
    0,                          /* tp_hash  */
    0,                          /* tp_call */
    0,                          /* tp_str */
    0,                          /* tp_getattro */
    0,                          /* tp_setattro */
    0,                          /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT |
        Py_TPFLAGS_BASETYPE,    /* tp_flags */
    "HDL simulation wrapped in python c-extension",                   /* tp_doc */
    0,                          /* tp_traverse */
    0,                          /* tp_clear */
    0,                          /* tp_richcompare */
    0,                          /* tp_weaklistoffset */
    0,                          /* tp_iter */
    0,                          /* tp_iternext */
	Sim_methods,                /* tp_methods */
    0,                          /* tp_members */
	Sim_getters_setters,        /* tp_getset */
    0,                          /* tp_base */
    0,                          /* tp_dict */
    0,                          /* tp_descr_get */
    0,                          /* tp_descr_set */
    0,                          /* tp_dictoffset */
    0,                          /* tp_init */
    0,                          /* tp_alloc */
	Sim_new,                    /* tp_new */
};


static PyModuleDef Sim_module = {
    PyModuleDef_HEAD_INIT,
    "{{module_name}}",
    "Generated module with simulation for {{top_name}}",
    -1,
    nullptr, nullptr, nullptr, nullptr,
    nullptr
};

PyMODINIT_FUNC
PyInit_{{module_name}}(void)
{
    PyObject* m;

    if (PyType_Ready(&Sim_pytype) < 0)
        return nullptr;

    if (PyType_Ready(&SignalMemProxy_pytype) < 0)
        return nullptr;

    m = PyModule_Create(&Sim_module);
    if (!m) {
    	return nullptr;
    }
    Py_INCREF(&Sim_pytype);
    PyModule_AddObject(m, "{{module_name}}", (PyObject *)&Sim_pytype);

    Py_INCREF(&SignalMemProxy_pytype);
    PyModule_AddObject(m, "SignalMemProxy", (PyObject *)&SignalMemProxy_pytype);
    return m;
}

